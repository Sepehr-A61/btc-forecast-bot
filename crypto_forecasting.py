# -*- coding: utf-8 -*-
"""crypto forecasting.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1stF1QRu6VZKsL_icW4zBsj9aSh6WXA9p
"""

# ---------------------------
# BTC Daily Forecast Script (GitHub-Ready)
# ---------------------------

import yfinance as yf
import pandas as pd
import pandas_ta as ta
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import classification_report, confusion_matrix
from prophet import Prophet
import matplotlib.pyplot as plt
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.base import MIMEBase
from email import encoders
import os
from datetime import datetime

# ---------------------------
# 1Ô∏è‚É£ Email Configuration (GitHub Secrets)
# ---------------------------
EMAIL_USER = os.getenv("EMAIL_USER")      # <-- from GitHub Secrets
EMAIL_PASS = os.getenv("EMAIL_PASS")      # <-- from GitHub Secrets

def send_email(to_emails, subject, body, attachments=None):
    """Send email with optional attachments."""
    msg = MIMEMultipart()
    msg["From"] = EMAIL_USER
    msg["To"] = ", ".join(to_emails)
    msg["Subject"] = subject
    msg.attach(MIMEText(body, "plain"))

    if attachments:
        for attachment in attachments:
            with open(attachment, "rb") as f:
                part = MIMEBase("application", "octet-stream")
                part.set_payload(f.read())
            encoders.encode_base64(part)
            part.add_header("Content-Disposition", f"attachment; filename={os.path.basename(attachment)}")
            msg.attach(part)

    try:
        server = smtplib.SMTP("smtp.gmail.com", 587)
        server.starttls()
        server.login(EMAIL_USER, EMAIL_PASS)
        server.send_message(msg)
        server.quit()
        print("‚úÖ Email sent successfully!")
    except Exception as e:
        print(f"‚ùå Error sending email: {e}")


# ---------------------------
# 2Ô∏è‚É£ Download BTC Data
# ---------------------------
btc = yf.download("BTC-USD", start="2015-01-01", end=datetime.now().strftime("%Y-%m-%d"), auto_adjust=True)
btc.dropna(inplace=True)

# ---------------------------
# 3Ô∏è‚É£ Technical Indicators
# ---------------------------
btc["rsi"] = ta.rsi(btc["Close"], length=14)
macd = ta.macd(btc["Close"])
btc["macd"] = macd.iloc[:, 0]
btc["ema50"] = ta.ema(btc["Close"], length=50)
btc["ema200"] = ta.ema(btc["Close"], length=200)
bb = ta.bbands(btc["Close"], length=20)
btc["bb_high"] = bb.iloc[:, 0]
btc["bb_low"] = bb.iloc[:, 2]
btc.dropna(inplace=True)

# ---------------------------
# 4Ô∏è‚É£ Target Variable
# ---------------------------
btc["future_close"] = btc["Close"].shift(-1)
btc["target"] = (btc["future_close"] > btc["Close"]).astype(int)
btc.dropna(inplace=True)

# ---------------------------
# 5Ô∏è‚É£ Train Model
# ---------------------------
features = ["rsi", "macd", "ema50", "ema200", "bb_high", "bb_low"]
X = btc[features]
y = btc["target"]

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, shuffle=False, random_state=42)
model = RandomForestClassifier(n_estimators=200, random_state=42)
model.fit(X_train, y_train)

print(f"Model Accuracy: {model.score(X_test, y_test):.3f}")
print("\nClassification Report:\n", classification_report(y_test, model.predict(X_test)))
print("\nConfusion Matrix:\n", confusion_matrix(y_test, model.predict(X_test)))

# ---------------------------
# 6Ô∏è‚É£ Forecast with Prophet
# ---------------------------
prophet_df = btc.reset_index()[["Date", "Close"]].rename(columns={"Date": "ds", "Close": "y"})
prophet = Prophet(daily_seasonality=True)
prophet.fit(prophet_df)

future = prophet.make_future_dataframe(periods=30)
forecast = prophet.predict(future)

# ---------------------------
# 7Ô∏è‚É£ Visualization (Last 30 Days + 30-Day Forecast)
# ---------------------------
today = btc.index.max()
one_month_ago = today - pd.Timedelta(days=30)
btc_recent = btc.loc[btc.index >= one_month_ago]
forecast_recent = forecast.loc[forecast["ds"] > today]

plt.figure(figsize=(12, 6))
plt.plot(btc_recent.index, btc_recent["Close"], label="Actual (Last 30 Days)", color="black", linewidth=2)
plt.plot(forecast_recent["ds"], forecast_recent["yhat"], label="Forecast (Next 30 Days)", color="orange", linestyle="--", linewidth=2)
plt.fill_between(
    forecast_recent["ds"],
    forecast_recent["yhat_lower"],
    forecast_recent["yhat_upper"],
    color="orange",
    alpha=0.2,
    label="Confidence Interval",
)
plt.title("BTC Price: Last 30 Days + Next 30 Days Forecast", fontsize=14)
plt.xlabel("Date")
plt.ylabel("Price (USD)")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.savefig("BTC_forecast_report.png")

# ---------------------------
# 8Ô∏è‚É£ Save Forecast CSV
# ---------------------------
forecast.to_csv("BTC_forecast.csv", index=False)

# ---------------------------
# 9Ô∏è‚É£ Send Daily Email
# ---------------------------
send_email(
    to_emails=["nazanin.asadi.a@gmail.com", "kianakia399@gmail.com", "moses.abdi@gmail.com"],  # üîÅ add more recipients here
    subject=f"Daily BTC Forecast Report ({datetime.now().strftime('%Y-%m-%d')})",
    body="Attached is today's BTC forecast report and visualization.",
    attachments=["BTC_forecast.csv", "BTC_forecast_report.png"],
)
